pipeline {
  agent any
  environment {
    AWS_REGION = "us-east-1"
    CLUSTER_NAME = "my-cluster"  // Matches Terraform EKS cluster name
    ECR_REPO = "891377219096.dkr.ecr.us-east-1.amazonaws.com"
  }
  stages {
    stage('Install AWS CLI') {
  steps {
    script {
      sh '''
        if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI v2..."
          INSTALL_DIR="/home/jenkins/.aws-cli"  # User-writable directory
          mkdir -p "$INSTALL_DIR"  # Create if it doesn't exist
          cd /tmp
          curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          ./aws/install --install-dir "$INSTALL_DIR" --bin-dir "$INSTALL_DIR/bin"  # Install to custom dir
          rm -rf awscliv2.zip aws
          export PATH="$INSTALL_DIR/bin:$PATH"  # Add to PATH for this session
          echo "export PATH=\"$INSTALL_DIR/bin:\$PATH\"" >> ~/.bashrc  # Persist for future shells (optional)
        else
          echo "AWS CLI already installed."
        fi
        aws --version  # Verify installation
      '''
    }
  }
}
    stage('Checkout') {
      steps {
        git 'https://github.com/Hibalem/ecommerce.git'
      }
    }
    stage('Build Docker Images') {
      steps {
        script {
          // Build images for the microservices (as per project guide's app deployment)
          sh 'docker build -t user-service ./services/user-service'
          sh 'docker build -t product-service ./services/product-service'
          sh 'docker build -t order-service ./services/order-service'
        }
      }
    }
    stage('Push to ECR') {
      steps {
        script {
          withAWS(credentials: 'aws-credentials') {
            // Check if AWS CLI is available (now redundant, but keep for logging)
            sh 'which aws || echo "AWS CLI not found"'
            
            // Fixed login: Use $$ for proper escaping in multi-line sh
            sh """
              PASSWORD=\$\$(aws ecr get-login-password --region \${AWS_REGION})
              echo \$PASSWORD | docker login --username AWS --password-stdin \${ECR_REPO}
            """
            
            // Tag and push each service (expands on project guide's Docker push)
            sh "docker tag user-service:latest \${ECR_REPO}/user-service:latest && docker push \${ECR_REPO}/user-service:latest"
            sh "docker tag product-service:latest \${ECR_REPO}/product-service:latest && docker push \${ECR_REPO}/product-service:latest"
            sh "docker tag order-service:latest \${ECR_REPO}/order-service:latest && docker push \${ECR_REPO}/order-service:latest"
          }
        }
      }
    }
    stage('Deploy to Kubernetes') {
      steps {
        script {
          withAWS(credentials: 'aws-credentials') {
            // Update kubeconfig for EKS (as per project guide)
            sh "aws eks update-kubeconfig --region \${AWS_REGION} --name \${CLUSTER_NAME}"
            
            // Apply Kubernetes manifests (assumes k8s/app-deployment.yml exists in repo, per guide)
            sh 'kubectl apply -f k8s/app-deployment.yml'
            
            // Optional: Verify deployment
            sh 'kubectl get pods'
          }
        }
      }
    }
  }
  post {
    success {
      echo 'Deployment successful! Check Kubernetes and monitoring dashboards.'
    }
    failure {
      echo 'Pipeline failed. Check logs, ensure AWS CLI is installed, and verify Terraform infrastructure.'
    }
  }
}